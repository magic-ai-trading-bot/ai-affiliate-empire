# ============================================================================
# PostgreSQL Configuration for AI Affiliate Empire
# ============================================================================
# Purpose: Production-optimized PostgreSQL settings
# Version: PostgreSQL 14+
# Hardware: 4-8 CPU cores, 8-16GB RAM, SSD storage
# Workload: Mixed OLTP (high writes) + Analytics (aggregations)
# ============================================================================

# ============================================================================
# CONNECTION SETTINGS
# ============================================================================

# Maximum connections (conservative, rely on PgBouncer for pooling)
# Formula: (CPU cores * 2) + effective_spindle_count + buffer
# With PgBouncer: Keep lower (100-200)
max_connections = 200

# Superuser reserved connections
superuser_reserved_connections = 3

# ============================================================================
# MEMORY SETTINGS (for 8GB RAM server)
# ============================================================================

# Shared buffers (25% of RAM for dedicated DB server)
# 8GB RAM = 2GB shared_buffers
# 16GB RAM = 4GB shared_buffers
shared_buffers = 2GB

# Effective cache size (50-75% of total RAM)
# Helps query planner estimate disk cache
# 8GB RAM = 6GB
# 16GB RAM = 12GB
effective_cache_size = 6GB

# Maintenance work mem (for VACUUM, CREATE INDEX, etc.)
# 5-10% of RAM, max 2GB per operation
maintenance_work_mem = 512MB

# Work mem (per query operation - sort, hash join)
# Formula: (Total RAM * 0.25) / max_connections
# 8GB * 0.25 / 200 = 10MB
# Increase for analytics: 32-64MB
work_mem = 32MB

# Huge pages (improve memory management)
# Options: try, on, off
huge_pages = try

# ============================================================================
# WAL (Write-Ahead Log) SETTINGS
# ============================================================================

# WAL level (for replication and point-in-time recovery)
# Options: minimal, replica, logical
wal_level = replica

# WAL buffers (auto-tuned to 1/32 of shared_buffers, max 16MB)
# -1 = auto
wal_buffers = -1

# Min WAL size (keep at least this much WAL)
min_wal_size = 1GB

# Max WAL size (checkpoint triggered when exceeded)
max_wal_size = 4GB

# WAL compression (reduce I/O)
# Options: on, off, pglz, lz4, zstd
wal_compression = on

# WAL sync method (how to flush WAL to disk)
# Options: fsync, fdatasync, open_sync, open_datasync
# fdatasync is fastest on Linux
wal_sync_method = fdatasync

# Commit delay (group commits for better throughput)
# 0 = disabled, 10-100 microseconds for high-throughput
commit_delay = 10
commit_siblings = 5

# ============================================================================
# CHECKPOINTS
# ============================================================================

# Checkpoint timeout (time-based checkpoint trigger)
# Default: 5min, increase for write-heavy: 15-30min
checkpoint_timeout = 15min

# Checkpoint completion target (spread checkpoint I/O)
# 0.0-1.0, higher = slower checkpoint, less I/O spikes
# Recommended: 0.9
checkpoint_completion_target = 0.9

# Checkpoint warning (log if checkpoints happen too frequently)
checkpoint_warning = 30s

# ============================================================================
# QUERY PLANNER
# ============================================================================

# Random page cost (SSD vs HDD)
# HDD: 4.0, SSD: 1.1-1.5
random_page_cost = 1.1

# Effective I/O concurrency (parallel I/O operations)
# SSD: 200, HDD: 2
effective_io_concurrency = 200

# Default statistics target (histogram buckets for query planning)
# Default: 100, increase for complex queries: 100-500
default_statistics_target = 100

# ============================================================================
# PARALLEL QUERY EXECUTION
# ============================================================================

# Max parallel workers per gather (parallel query threads)
max_parallel_workers_per_gather = 4

# Max parallel workers (total across all queries)
max_parallel_workers = 8

# Max parallel maintenance workers (for CREATE INDEX, VACUUM)
max_parallel_maintenance_workers = 4

# Min parallel table scan size (parallel scan threshold)
min_parallel_table_scan_size = 8MB
min_parallel_index_scan_size = 512kB

# ============================================================================
# BACKGROUND WORKERS
# ============================================================================

# Max worker processes (background + parallel)
max_worker_processes = 8

# Autovacuum workers (automatic VACUUM)
autovacuum_max_workers = 3

# ============================================================================
# AUTOVACUUM (Critical for OLTP performance)
# ============================================================================

# Enable autovacuum
autovacuum = on

# Autovacuum naptime (sleep between runs)
# Default: 1min, decrease for high-write: 10-30s
autovacuum_naptime = 30s

# Vacuum threshold (min dead tuples before VACUUM)
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.1

# Analyze threshold (min changes before ANALYZE)
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.05

# Autovacuum work mem (per worker)
autovacuum_work_mem = 512MB

# Vacuum cost limit (throttle VACUUM I/O)
# -1 = use vacuum_cost_limit
autovacuum_vacuum_cost_limit = -1

# Vacuum cost delay (milliseconds between I/O operations)
# Lower = faster VACUUM, higher I/O impact
vacuum_cost_delay = 2ms

# ============================================================================
# LOGGING
# ============================================================================

# Log destination
# Options: stderr, csvlog, syslog
log_destination = 'stderr'

# Logging collector (required for log rotation)
logging_collector = on

# Log directory and filename
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'

# Log rotation
log_rotation_age = 1d
log_rotation_size = 100MB

# Log truncation (on/off)
log_truncate_on_rotation = on

# Log line prefix (timestamp, user, database, pid, etc.)
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# Log timezone
log_timezone = 'UTC'

# ============================================================================
# SLOW QUERY LOGGING (Performance Monitoring)
# ============================================================================

# Log queries slower than N milliseconds
# 0 = all queries, -1 = disabled
# Production: 100-1000ms
log_min_duration_statement = 500

# Log statement types
# Options: none, ddl, mod, all
log_statement = 'ddl'

# Log lock waits (queries waiting for locks)
log_lock_waits = on

# Deadlock timeout (time to wait before checking for deadlock)
deadlock_timeout = 1s

# Log temp files (queries using disk temp files)
log_temp_files = 10MB

# Log checkpoints
log_checkpoints = on

# Log connections and disconnections
log_connections = off
log_disconnections = off

# Log duration of completed statements
log_duration = off

# ============================================================================
# STATISTICS COLLECTION
# ============================================================================

# Track activity (pg_stat_activity)
track_activities = on

# Track counts (pg_stat_user_tables)
track_counts = on

# Track I/O timing (pg_stat_statements, adds overhead)
track_io_timing = on

# Track functions (pg_stat_user_functions)
track_functions = all

# pg_stat_statements extension (query performance tracking)
shared_preload_libraries = 'pg_stat_statements'

# pg_stat_statements settings
pg_stat_statements.max = 10000
pg_stat_statements.track = all
pg_stat_statements.track_utility = on
pg_stat_statements.save = on

# ============================================================================
# REPLICATION (for High Availability)
# ============================================================================

# Max WAL senders (replication connections)
max_wal_senders = 10

# Max replication slots
max_replication_slots = 10

# WAL keep size (WAL retention for replicas)
wal_keep_size = 1GB

# Hot standby (allow queries on replica)
hot_standby = on

# Hot standby feedback (prevent query conflicts on replica)
hot_standby_feedback = on

# ============================================================================
# ARCHIVE MODE (for Point-in-Time Recovery)
# ============================================================================

# Archive mode (enable WAL archiving for backups)
archive_mode = on

# Archive command (copy WAL files to backup location)
# Example: cp %p /var/backups/postgresql/wal/%f
archive_command = 'test ! -f /var/backups/postgresql/wal/%f && cp %p /var/backups/postgresql/wal/%f'

# Archive timeout (force WAL segment switch)
# 0 = disabled, 300-900s for regular backups
archive_timeout = 300s

# ============================================================================
# CLIENT CONNECTION DEFAULTS
# ============================================================================

# Timezone
timezone = 'UTC'

# Locale
lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'
lc_time = 'en_US.UTF-8'

# Default text search config
default_text_search_config = 'pg_catalog.english'

# Statement timeout (cancel queries running too long)
# 0 = disabled, 30000-300000ms (30s-5min) for production
statement_timeout = 300000

# Idle in transaction timeout (kill idle transactions)
# 0 = disabled, 60000-300000ms (1-5min) recommended
idle_in_transaction_session_timeout = 300000

# ============================================================================
# SECURITY
# ============================================================================

# SSL (enable for encrypted connections)
ssl = off
# ssl_cert_file = '/etc/ssl/certs/postgresql.crt'
# ssl_key_file = '/etc/ssl/private/postgresql.key'
# ssl_ca_file = '/etc/ssl/certs/ca-bundle.crt'

# Password encryption
password_encryption = scram-sha-256

# ============================================================================
# RESOURCE MANAGEMENT
# ============================================================================

# Shared memory type
# Options: mmap, sysv, windows
dynamic_shared_memory_type = posix

# Temp file limit (per session)
# -1 = unlimited
temp_file_limit = -1

# ============================================================================
# EXTENSIONS
# ============================================================================

# Preload shared libraries
# pg_stat_statements: Query performance tracking
# auto_explain: Automatic EXPLAIN for slow queries
shared_preload_libraries = 'pg_stat_statements'

# Auto explain (automatically log query plans)
# session_preload_libraries = 'auto_explain'
# auto_explain.log_min_duration = 1000
# auto_explain.log_analyze = on
# auto_explain.log_buffers = on
# auto_explain.log_timing = on
# auto_explain.log_triggers = on
# auto_explain.log_verbose = on
# auto_explain.log_nested_statements = on

# ============================================================================
# NOTES
# ============================================================================
# 1. Apply configuration:
#    sudo systemctl restart postgresql
#    OR
#    docker-compose restart postgres
#
# 2. Reload without restart (for some settings):
#    SELECT pg_reload_conf();
#
# 3. Check current settings:
#    SHOW all;
#    SHOW shared_buffers;
#
# 4. Monitor performance:
#    - pg_stat_statements: Top slow queries
#    - pg_stat_user_tables: Table I/O statistics
#    - pg_stat_activity: Active connections
#
# 5. Tune for your workload:
#    - More RAM: Increase shared_buffers, effective_cache_size
#    - More CPU: Increase max_parallel_workers
#    - More writes: Increase wal_buffers, checkpoint_timeout
#    - Analytics: Increase work_mem, default_statistics_target
#
# 6. Performance testing:
#    pgbench -i -s 50 dbname
#    pgbench -c 10 -j 2 -t 1000 dbname
#
# 7. Monitoring queries:
#    - Slow queries: SELECT * FROM pg_stat_statements ORDER BY total_exec_time DESC;
#    - Cache hit ratio: SELECT * FROM pg_stat_database WHERE datname = 'ai_affiliate_empire';
#    - Index usage: SELECT * FROM pg_stat_user_indexes;
# ============================================================================
